# HTTP의 이해


### HTTP
-  **HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜입니다**라고 공식문서에는 적혀있다. 
- 프론트 & 백 구분없이 서로 요청과 응답을 통해 데이터를 주고 받을 수 있으니 HTTP는 필수로 알아야 한다.

#### 무슨 의미야?
- 프로토콜의 정의를 보면 규칙의 집합이다. (규약)
- 결국은 넷상에서 **데이터를 주고 받을 때 이런 방식으로 규칙을 지키면서 교환하자**라고 약속한 것이라고 이해했다.
- 결국 웹에서 클라이언트와 서버간에 데이터를 주고받을때 사용하는 프로토콜이라고 이해하면 된다. 
  - "우리 통신할떄 HTTP를 사용해서 대화하자."
* 왜 이런 약속을 했지? 보다 아 그냥 그렇게 하려고 정한 약속이구나라고만 인지하고 있어도 무방하다. 


### HTTPS
- HTTP의 보안 버전이다. 
- HTTP로 통신을 했을때 데이터가 텍스트로 전송되어 접근하는 사람은 누구나 다 읽을 수 있고 이해할 수 있는반면, HTTPS는 전송하기 전 데이터를 암호화하여 중간에 누군가 가로채더라도 쉽게 이해할 수 없게 한다.
- 또 HTTPS에서 TLS이라는 프로토콜을 제공하는데, 이 녀석이 데이터 암호화를 해주는 역할을 한다. 
  - TLS은 변조나 메시지 위조를 방지하도록 설계되었다.

> HTTP는 데이터를 전송할 때 접근하는 유저가 이해할 수 있는 데이터, HTTPS는 데이터가 암호화 되어 있어 유저가 쉽게 이해할 수 없는 데이터 (확인하려면 인증 같은게 필요)

### 애플리케이션 레이어
- 여러 의미로 사용된다고 한다.
- OSI 7계층에 속하는 레이어로 우리가 실제 구현하는 레이어라고 생각하면 될 것 같다.
- 실제로는 1 -> 2 -> 3 -> 4까지만 하고 7(응용)으로 넘어간다고 한다.
- 1계층인 물리계층은 물리적 장비라고 하는데 통신 단위가 1과 0으로 이루어진 2진수 비트단위라고 한다. 
  - 컴퓨터는 2진수만 알 수 있다고 하니 당연한건가 ..?

#### 2, 3, 4, 7 계층
- 우선 2, 3, 4, 7에 대한 내용만 훑어보고 다음에 OSI 7계층에 대해 다시 파악해보자.
   
**데이터 링크 계층 - 2계층**
> - 하드웨어를 일종의 추상화함.
> - 각 기기를 구분한다.
> - 물리적 주소인 MAC address를 부여하여 기기의 주소를 파악할 수 있다.
   
**네트워크 계층 - 3계층**
> - 물리적 장비인 라우터를 통해서 전달된다고 한다.
> - 전달이 되려면 주소를 알아야 하는데 결국 여기서 IP address가 사용된다.
> - 인터넷 프로토콜
> - 네트워크의 패킷은 들어봤지만 이것이 쪼개져서 어떻게 이동하고 데이터가 도착할 목적 주소를 어떻게 칮는지 같은 원리는 좀 더 알아봐야할 것 같다. 
   
**전송 계층 - 4계층**
> - 전송방식은 TCP, UDP를 사용한다. 
> - 신뢰성 있는 데이터를 주고 받게 해주는 역할을 한다고 한다. 
> - 포트 넘버도 사용되어 프로그램? 혹은 목적지를 잘 찾아갈 수 있게 하는 것 같다.
   
**응용 계층 - 7계층**
> - HTTP, SMTP, FTP 등 여러가지 조존재
> - HTTPS도 사용한다.
> - 여기서부터 직접 만들어야 하는 부분
> - 기본적인 TCP/IP 구조에서 TLS가 붙으면 HTTPS가 된다고 한다. 



### 클라이언트-서버 모델
- 하나 혹은 다수의 클라이언트가 리소스나 서비스에 접근하기 위해 중앙 집중식 서버와 통신하는 아키텍처라고 한다. 
  - 클라이언트-서버 모델이 등장하기 전 메인 프레임 모델이 있었다고 한다.
  - P2P 모델이란것도 있다. (소리바다 ...)
- 간단하게 클라이언트가 요청을 하면 서버가 요청을 받아 응답하여 데이터를 건네주는 모델이다.
  - 즉, 우리가 구글을 접속하면 구글의 데이터센터같은 곳에서 구글페이지를 띄우기 위한 데이터를 응답해준다.
- 여기서 네트워크를 통해 데이터가 전송되는 방식을 정의하는 HTTP 혹은 TCP/IP와 같은 프로토콜이 사용되는 것이다.
  - 서버에서는 응답을 해줄 때 HTML 같은 하이퍼미디어 형태로 전송해줄 수도 있다. 
- 클라이언트는 서버에 요청을 할때 어떤 것을 요청할 것인지 리소스를 식별 할 수 있는 부가 정보를 담아서 요청해야한다. 
  - HTTP 같은 경우는 메소드, 메시지 등을 담아서 보낸다.


### 무상태 프로토콜 (Stateless)
- HTTP는 무상태 프로토콜이다. 기본적으로 이전 요청에 대한 정보를 가지고 있지 않기 때문에 요청을 늘 새롭다.
  - stateful 설계를 하려면 쿠키와 세션같은 것을 사용하여 설계한다.
  - stateful은 이전 상호 작용에 대한 정보를 유지하는 것.
  - 반면 stateless은 이전 상호 작용에 대한 정보를 유지하지 않는다.
- 무상태 프로토콜은 서버가 클라이언트의 상태를 보존하지 않는다가 기본이다.
  - 장점 : 서버의 확장성(세션 관리를 하지 않기 때문)
  - 단점 : 클라이언트가 추가 데이터를 전송해야한다.

* 기억나는 예시가 하나 있다. 햄버거로 변형해보자.
> - A: **햄버거** 얼마인가요?
> - B: **5천원** 입니다.
> - A: **햄버거 1개** 주세요
> - B: **햄버거 1개는 5천원**입니다. **현금과 카드** 어떤 것으로 결제하실건가요?
> - A: **햄버거 1개**를 **현금**으로 결제할게요
> - B: 5천원 결제되었습니다. 
이렇게 다시 보니까 이해가 잘 되는 것 같다. 
Stateless의 반대인 Stateful은 고객의 요청을 저장하는 반면, Stateless은 서버에서 고객의 정보를 저장하지 않기 때문에 요청할때마다 다시 정보를 추가의 추가를 해서 요청해야하는 것 같다.


### 상태유지 (Stateful)
- 이전 상호 작용에 대한 정보를 유지한다. 
- 각 요청은 이전 요청의 컨텍스트를 기반으로 처리된다.
- 그리고 서버는 클라이언트-서버의 상호 작용 상태에 대한 정보를 유지 및 관리한다. 
- TCP가 있다.
  - TCP는 두 장치간의 연결을 유지해야하고 전송되는 데이터가 오류 없이 순서대로 전달되어야 한다. 
- HTTP로 Stateful한 설계를 한다하면 쿠키와 세션을 사용하면 된다. 
> - 챗GPT는 무상태 프로토콜 시스템으로 설계 되었는데 이전 대화 내용을 보존하는 것처럼 보인다. (완전 리프레시 했을 경우 제외) 이것은 쿠키와 세션을 이용하여 사용자의 이전 상호 작용을 저장한다고 한다.
> - 출처 : 쟤가 직접 말했음.

### HTTP Cookie & HTTP Session
- 쿠키와 세션은 둘 다 웹 애플리케이션에서 상태를 유지하기 위한 매커니즘이지만 구현과 사용방법이 다르다. 
- 쿠키는 클라이언트 측에 저장되며 여러 요청에서 세션 정보를 유지하는데 자주 사용된다. 
- 세션은 서버 측에 저장되며 클라이언트에 대한 모든 종류의 상태 정보를 유지하는 데 사용된다. 

#### Cookie
- 상태를 유지(stateful)하고 사용자에 대한 정보를 기억하기 위해 웹 서버에서 사용하는 매커니즘이다.
- 웹 서버에 의해 클라이언트의 컴퓨터에 저장되는 작은 텍스트 파일이다.
- 클라이언트가 서버에 요청을 보내면 쿠키가 요청과 함께 전송된다.
- 서버는 쿠키를 읽고 기본 설정이나 로그인 정보와 같은 클라이언트에 대한 정보를 검색할 수 있다. 
- 쿠키는 서버가 사용자의 신원 및 기타 관련 정보를 기억할 수 있도록 여러 요청에서 사용자 세션을 유지하는데 자주 사용된다. 
- 추적 및 분석 목적으로도 사용될 수 있다. (쿠키, 캐시 삭제 등등 꼭하기)

#### Session
- 상태를 유지하기 위한 서버측 매커니즘이다.
- 클라이언트가 웹 서버에 처음 연결하면 서버는 클라이언트에 대한 세션 개체를 만들고 고유한 세션 ID를 할당한다. 
- 이 세션 ID는 클라이언트 측에 쿠키로 저장되고나 다른 방식으로 클라이언트에 다시 전달된다. 
- 로그인 정보, 장바구니 내용 또는 기본 설정과 같이 서버가 클라이언트에 대해 기억해야 하는 모든 종류의 데이터가 포함될 수 있다. 
- 사용자가 장바구니에 상품을 담을때 사용자만 기억하고 있는게 아닌 서버도 같이 기억을 해야 나중에 재로그인 시 무엇을 담았는지 알 수 있다.

### HTTP 메세지
- Request(요청)에서 쓰인다. 
- Response(응답)에서도 쓰인다.
- 메세지에는 크게 URL과 HTTP 메소드, 프로토콜 버전이 담긴다.
- 주소 요청으로 무엇을 할 것인지 결정한다.
- 리소스에 수행하길 원하는 행동으로 HTTP 메소드를 구분하여 요청한다고 이해했다.
  - 게시판 리스트를 얻고 싶다. (GET localhost:80/boards)
  - 게시판 하나를 보고 싶다. (GET localhost:80/boards/:id)
  - 게시판 하나를 삭제하고 싶다. (DELETE localhost80:/boards/:id)
  - 등등...
- 그리고 몇몇 메소드들은 멱등성을 지니고 있다.
  - **멱등성은 같은 액션을 여러번 취해도 그 결과가 달라지지 않는것을 의미한다.**
1. PUT 
  - 리소스를 전부 다 바꿀때는 멱등성을 지닌다. 
  - 덮어쓰기
2. OPTIONS
  - 헤더 정보확인
  - URL 요청응답이 정상적인지 등등의 확인이 필요할때 
  - 신기하다. 

3. POST
- 멱등성을 보장하지 않는다.
  - 간단하게 회원가입을 예시로 들어주셨는데 결국 회원가입 1번 요청 시 서버에서 데이터가 추가되어 상태가 변경되었기 때문에 멱등성에 위배된다.
- PATCH 또한 마찬가지 일부분만 업데이트 되도록 구현할 수도 있기 때문에 멱등성에 위배된다. 

4. DELETE
- 멱등성을 보장한다.

- DELETE 메소드의 의문점 : 누군가가 게시판 한개를 지우고 게시판 리스트를 요청했다면 서버의 상태가 데이터 한개 삭제로 변경이 되었다고 생각드는데 이 부분이 왜 멱등성을 보장한다고 하는걸까 ?
- **PUT, DELETE 는 한번 수정, 삭제가 되면 여러번 요청해도 같은 상태를 유지하는게 원칙이다.**라고 하는데 아무리 생각해도 이해가 잘 가지 않는다. 보는 기준을 달리 해야하나 ? (메소드의 역할 기준 ?, 연산 기준?, 리소스 변경 기준 ??)
- DELETE를 할 시 서버의 리소스는 하나 삭제된 상태이다. 그 이후 요청을 할 시 더 이상 삭제할것이 없고 서버의 상태는 그대로이니 멱등성이 보장된다. 즉, 처음 요청의 결과에 의해 상태 변화가 없으면 멱등성이 보장된다고 볼 수 있다. 

#### Content-Type : multipart/form-data
- 이미지, 비디오 또는 오디오 파일과 같은 파일을 포함하는 양식을 제출할 때 HTTP 메시지에 사용되는 인코딩 유형이다.
- 요청의 여러 부분을 단일 메시지로 결합할 수 있으며 각 부분에는 고유한 MIME 유형과 콘텐츠가 있다.


### HTTP 상태 코드 (status code)
[HTTP 상태코드 공식문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Status).
- 100, 200, 300, 400, 500 이 존재한다. 
- 주로 많이 사용하는 번대는 200, 400, 500이다.
- 200번대 : 서버에서 응답이 정상적으로 이루어졌다는 것을 알려준다.
- 400번대 : 클라이언트의 요청이 잘못되었다는 것을 알린다.
- 500번대 : 서버에러(보통 유저에게 보여주는 것을 지양하는 번대이다.)


## 학습 키워드
* HTTP(Hypertext Transfer Protocol)
* HTTP와 HTTPS의 차이(TLS)
* 클라이언트-서버 모델
* stateless와 stateful
* HTTP Cookie와 HTTP Session
* HTTP 메시지 구조
  * HTTP 요청(Reuqest)와 응답(Response)
    * multipart/form-data
  * HTTP 요청 메서드(HTTP request methods)
    * 멱등성
  * HTTP 응답 상태 코드(HTTP response status code)
    * 리다이렉션