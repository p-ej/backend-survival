# HTTP의 이해


### HTTP
-  **HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜입니다**라고 공식문서에는 적혀있다. 
- 프론트 & 백 구분없이 서로 요청과 응답을 통해 데이터를 주고 받을 수 있으니 HTTP는 필수로 알아야 한다.

#### 무슨 의미야?
- 프로토콜의 정의를 보면 규칙의 집합이다. 
- 결국은 넷상에서 **데이터를 주고 받을 때 이런 방식으로 규칙을 지키면서 교환하자**라고 약속한 것이라고 이해했다.
* 왜 이런 약속을 했지? 보다 아 그냥 그렇게 하려고 정한 약속이구나라고만 인지하고 있어도 무방하다. (추후에 세세한 내용을 파악해보도록)


### 애플리케이션 레이어
- 여러 의미로 사용된다고 한다.
- OSI 7계층에 속하는 레이어로 우리가 실제 구현하는 레이어라고 생각하면 될 것 같다.
- 실제로는 1 -> 2 -> 3 -> 4까지만 하고 7(응용)으로 넘어간다고 한다.
- 1계층인 물리계층은 물리적 장비라고 하는데 통신 단위가 1과 0으로 이루어진 2진수 비트단위라고 한다. 
  - 컴퓨터는 2진수만 알 수 있다고 하니 당연한건가 ..?

#### 2, 3, 4, 7 계층
- 우선 2, 3, 4, 7에 대한 내용만 훑어보고 다음에 OSI 7계층에 대해 다시 파악해보자.
   
** 데이터 링크 계층 - 2계층 **
> - 하드웨어를 일종의 추상화함.
> - 각 기기를 구분한다.
> - 물리적 주소인 MAC address를 부여하여 기기의 주소를 파악할 수 있다.
   
** 네트워크 계층 - 3계층 **
> - 물리적 장비인 라우터를 통해서 전달된다고 한다.
> - 전달이 되려면 주소를 알아야 하는데 결국 여기서 IP address가 사용된다.
> - 인터넷 프로토콜
> - 네트워크의 패킷은 들어봤지만 이것이 쪼개져서 어떻게 이동하고 데이터가 도착할 목적 주소를 어떻게 칮는지 같은 원리는 좀 더 알아봐야할 것 같다. 
   
** 전송 계층 - 4계층 **
> - 전송방식은 TCP, UDP를 사용한다. 
> - 신뢰성 있는 데이터를 주고 받게 해주는 역할을 한다고 한다. 
> - 포트 넘버도 사용되어 프로그램? 혹은 목적지를 잘 찾아갈 수 있게 하는 것 같다.
   
** 응용 계층 - 7계층 **
> - HTTP, SMTP, FTP 등 여러가지 조존재
> - HTTPS도 사용한다.
> - 여기서부터 직접 만들어야 하는 부분
> - 기본적인 TCP/IP 구조에서 TLS가 붙으면 HTTPS가 된다고 한다. 



### 클라이언트-서버 모델
- 둘 간의 통신이 어떻게 이루어질까 ? 
- 리소스를 요청한다. (URL)
- 클라이언트는 고객이라고 생각하자. 
  - 고객이 무언가를 주문한다.
- 서버는 고객의 요청을 들어주는 것이라 생각한다.
  - 고객 : 이것 좀 처리해주세요
  - 서버 : 네 (처리중)
- 서버에서는 응답을 해줄때 HTML 같은 하이퍼미디어 형태로 전송해줄 수도 있다. 
- 클라이언트는 서버에 요청을 할때 어떤 것을 요청할 것인지 리소스를 식별 할 수 있는 부가 정보를 담아서 요청해야한다. 


### 무상태 프로토콜 (Stateless)
- HTTP는 각각의 요청이 독립적이다.
- HTTP는 특정 상태를 유지하지 않는 특징을 갖고 있기 때문에 기본적으로 Stateless이라고 보면 될 것 같다.
- 무상태 프로토콜은 결국 서버가 클라이언트의 상태를 보존하지 않는다.
  - 클라이언트가 누군지에 대한 정보를 서버가 저장하고 있지 않다는 것 같다.
- 장점 : 서버의 확장성(세션 관리를 하지 않기 때문)
- 단점 : 클라이언트가 추가 데이터를 전송해야한다. (나를 인증해야하기 때문인가?)

* 기억나는 예시가 하나 있다. 햄버거로 변형해보자.
> - A: **햄버거** 얼마인가요?
> - B: **5천원** 입니다.
> - A: **햄버거 1개** 주세요
> - B: **햄버거 1개는 5천원**입니다. **현금과 카드** 어떤 것으로 결제하실건가요?
> - A: **햄버거 1개**를 **현금**으로 결제할게요
> - B: 5천원 결제되었습니다. 

이렇게 다시 보니까 이해가 잘 되는 것 같다. 
Stateless의 반대인 Stateful은 고객의 요청을 저장하는 반면, Stateless은 서버에서 고객의 정보를 저장하지 않기 때문에 요청할때마다 다시 정보를 추가의 추가를 해서 요청해야하는 것 같다.


### HTTP 메세지
- Request(요청)에서 쓰인다. 
- Response(응답)에서도 쓰인다.
- 메세지에는 크게 URL과 HTTP 메소드, 프로토콜 버전이 담긴다.
- 주소 요청으로 무엇을 할 것인지 결정한다.
- 리소스에 수행하길 원하는 행동으로 HTTP 메소드를 구분하여 요청한다고 이해했다.
  - 게시판 리스트를 얻고 싶다. (GET localhost:80/boards)
  - 게시판 하나를 보고 싶다. (GET localhost:80/boards/:id)
  - 게시판 하나를 삭제하고 싶다. (DELETE localhost80:/boards/:id)
  - 등등...
- 그리고 몇몇 메소드들은 멱등성을 지니고 있다.
  - **멱등성은 같은 액션을 여러번 취해도 그 결과가 달라지지 않는것을 의미한다.**
1. PUT 
  - 리소스를 전부 다 바꿀때는 멱등성을 지닌다. 
  - 덮어쓰기
2. OPTIONS
  - 헤더 정보확인
  - URL 요청응답이 정상적인지 등등의 확인이 필요할때 
  - 신기하다. 

- POST는 멱등성을 보장하지 않는다.
  - 간단하게 회원가입을 예시로 들어주셨는데 결국 회원가입 1번 요청 시 서버에서 데이터가 추가되어 상태가 변경되었기 때문에 멱등성에 위배된다.
- PATCH 또한 마찬가지 일부분만 업데이트 되도록 구현할 수도 있기 때문에 멱등성에 위배된다. 


음... DELETE 메소드의 의문점 : 누군가가 게시판 한개를 지우고 게시판 리스트를 요청했다면 서버의 상태가 데이터 한개 삭제로 변경이 되었다고 생각드는데 이 부분이 왜 멱등성을 보장한다고 하는걸까 ?
- **PUT, DELETE 는 한번 수정, 삭제가 되면 여러번 요청해도 같은 상태를 유지하는게 원칙이다.**라고 하는데 아무리 생각해도 이해가 잘 가지 않는다. 보는 기준을 달리 해야하나 ? (메소드의 역할 기준 ?, 연산 기준?, 리소스 변경 기준 ??)


### HTTP 상태 코드 (status code)
[HTTP 상태코드 공식문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Status).
- 100, 200, 300, 400, 500 이 존재한다. 
- 주로 많이 사용하는 번대는 200, 400, 500이다.
- 200번대 : 서버에서 응답이 정상적으로 이루어졌다는 것을 알려준다.
- 400번대 : 클라이언트의 요청이 잘못되었다는 것을 알린다.
- 500번대 : 서버에러(보통 유저에게 보여주는 것을 지양하는 번대이다.)


## 학습 키워드
* HTTP(Hypertext Transfer Protocol)
* HTTP와 HTTPS의 차이(TLS)
* 클라이언트-서버 모델
* stateless와 stateful
* HTTP Cookie와 HTTP Session
* HTTP 메시지 구조
  * HTTP 요청(Reuqest)와 응답(Response)
    * multipart/form-data
  * HTTP 요청 메서드(HTTP request methods)
    * 멱등성
  * HTTP 응답 상태 코드(HTTP response status code)
    * 리다이렉션