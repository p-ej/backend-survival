# Layered Architecture


### Layered Architecture ?
- 애플리케이션이나 시스템을 각가의 독립된 기능이 있는 별도의 집합을 계층으로 나누는 소프트웨어 아키텍처 패턴이라고 한다.
- 직번역 그대로 계층적인 구성을 이루며, 상위 혹은 하위 레이어로 구축된다.
- 쉽게 이전에 우리가 학습용으로 실습한 Rest API 서버를 보면 Controller에 각각의 라우터 핸들러들만 구성하고 그 안에 게시글을 만들고, 지우고, 수정하는 기능도 같이 구성했다. 
    - 이를 관심사 분리를 통해 컨르롤러는 Path를 통해서 요청이 들어오는 URL은 여기로 보내주는 통로역할만 하게 해주고, 그 통로에 해당하는 기능은 새로운 클래스 즉, 일명 Service(비즈니스) 계층을 통해 기능을 처리하게 해준다. 
    - 결국엔 Controller는 요청된 API가 무엇인지의 통로 역할. 그 통로에 해당되는 기능을 하는 역할을 하는 Service로 코드를 분리할 수 있다. 

```java
@PostMapping
private PostDto create(@RequestBody PostDto postDto) {
    PostDto createdPostDto = postService.createPostDto(postDto);
    return createdPostDto;
}
```
> - PostService안에 있는 createPostDto함수를 통해 Post가 만들어진다. 
> - 이렇게 코드와 레이어를 분리하면 유지보수에 용이하다.
   
- 일반적인 계층 구조는 프리젠테이션 계층, 비즈니스 계층, 데이터 액세스 계층으로 나뉜다.
    - 프리젠테이션 계층: 사용자와 상호 작용 처리
    - 비즈니스 계층: 핵심 애플리케이션 로직 처리
    - 데이터 액세스 계층: DB 혹은 데이터와의 상호 작용 처리

> 음 Layered Architecture는 결국에 모듈화를 통해 문제를 쉽게 파악하고 해결 혹은 유지보수나 테스트에 큰 이점을 가져다 준다고 볼 수 있을 것 같다. 

- `처음에는 계층을 그냥 나누는게 좋다라고만 인지하지 이게 왜 나누고 어떤 의미를 갖고 있는지는 깊게 생각해본적이 없는 것 같다. Nestjs의 구조는 Spring과 동일하다고 볼 수 있다. 각각의 책임을 나눔으로써 기능 수정이 필요하면 Service 파일만 보면 된다. `

- **결국에는 설계도 잘해야한다.**

#### 관심사의 분리 (Separation of Concerns)
- 소프트웨어 공학에서 기초가 되는 원리이다. 
    - 소프트웨어의 품질과, 유지관리 및 확장성을 개선하는데 도움이 되는 원칙이다.
- 한 소프트웨어의 기능을 독립적인 부부능로 나누는 계층 구조의 핵심 개념이라고 볼 수 있다.
    - 나중에 코드 수정하는데 있어서 하나의 기능을 고치는데 여러 군데(다른 파일, 같은 코드를 또 사용 등)를 고친다면 매우 불편할 것이다. 이를 모듈화나 어느 파일로 구분되게 한다면 좀 더 수정하기에도 편할 것이다.
- **독립적으로 나눈다.**에 중점을 두고 보면 좀 더 쉽게 이해할 수 있다. 
    - 예를 들어서 컨트롤러를 수정했는데 비즈니스 클래스에서 에러가 나면 곤란하듯..
- 변화하는 요구 사항에 적응과 시스템이 점점 거대해짐으로써 확장성이 좋아야한다. 



#### 응집도 & 결합도
- `응집도`
    - 하나에 기능에 대한 목적이 있는 코드가 해당 기능과 관련된 요소들이 얼마나 집중되어 있는가에 대한 척도를 나타내는 것 같다. 
    - 응집도가 낮으면 이 기능이 어떤 목적을 갖고 있는지 알 수가 없다.
- `결합도`
    - 하나의 기능에 대해 얼만큼의 모듈들이 의존하는가에 대한 척도를 나타내는 것 같다.
    - 해당 요소들이 서로 의존하는 정도 ? 
    - 서로 의존하면서 작동한다는 것은 추후 하나의 모듈이 문제생겼을 때 다른 모듈들도 문제가 생길 확률이 높다는 것. 
    - 결합도가 낮으면 각각의 모듈이 독립적이고 수정하기 쉽다. (오류도 낮음) 

> - 일반적으로 높은 응집도와 낮은 결합도를 구성하는 것이 바람직한 소프트웨어 구성이라고 볼 수 있다.
> - 모듈이나 구성 요소가 의미하는 바가 명확해야하고 코드의 구성또한 그래야한다. (설계가 쉬워지고 유지보수가 용이하기 때문에)
> - 모듈들이 서로 의존하는게 높은 소프트웨어보다 느슨하게 결합하여 응집도가 높고 결합도가 낮게 구성될 수 있도록 개발해 나가자

#### UUID
- 일반적인 고유 식별자라는 의미.
- 128 비트로 구성되어 있다.
- 5개 섹션은 **시간 기반 버전 번호, 타임스탬프, 클록 시퀀스 및 노드 식별자**를 나타낸다.
- 개체를 식별하는데 사용하는 고유한 식별자를 제공
- 데이터를 안정적이게 보관할 수 있는 용도로도 사용
- 개체의 고유 id를 쉽게 알아볼 수 있는 1, 2, 3 대신 UUID를 사용하여 보관

> - 물론 무조건 UUID를 사용할 수는 없는 노릇. 필요에 따라서 혹은 데이터의 중요도에 따라 시퀀스 number를 사용하는게 적절할 수도 있다. 
> - 그리고 ~ UUID를 너무 **과도하게 사용**하면 일반적인 시퀀스 number보다 많은 공간을 차지하기 때문에 쿼리 속도가 느려질 수 있다고 한다. (자주비교하는 연산이나 검색의 경우 연산에 대한 메모리 사용량 증가나 처리 시간이 느려질 수 있다.) 
> - 그래서 무작정 UUID를 사용하기보다 설계에 따라서 적절하게 사용하는 것이 좋다.

`사실 과도의 기준이 어느정도 까지인지는 가늠이 안간다 알아봐야겠다.`


## 학습 키워드
* 관심사의 분리
* 응집도
* 결합도
* Layered Atchitecture
* UUID
