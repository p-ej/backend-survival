# 애플리케이션 수준의 보안


### 의의
- 보안이라 함은 굉장히 광범우리 하다. 백엔드를 중점으로 알아보는 걸 목표로 한다.
- 우리가 만드는 애플리케이션 자체를 보호하는 데 중점을 둔다.

### 애플리케이션 보안 기본요소 중 3가지
- 애플리케이션 보안 요소는 여러가지가 있다. 이 중 3가지를 중점으로 알아본다.
1. 인증
2. 인가
3. 암호화

### 인증 (Authentication)
- **정의를 보자면 프로그램에 액세스하는 사용자 혹은 시스템의 신분을 확인하는 프로세스이다. 접근할 수 있는 권한을 부여하기 전에 사용자가 자신이 누군지 확인한다.**
  - 이는 무단 접근을 방지하고 중요 정보를 보호하는 데 도움된다.
- 쉽게 우리가 익히하는 로그인 과정이라고 볼 수 있다. (사용자 경험 관점)
- 나는 누구인가?에 대한 **증명과정**
- 오프라인으로 비유하자면 신분증으로 자신을 증명한다고 볼 수 있다.
- 온라인 같은 경우 아이디와 패스워드, OTP 등과 같은 인증 시스템으로 본다.

#### 특징
- 한 번 인증을 하고 나면 세션이 유지되는 동안 인증절차를 하지 않는다.
  - 매 요청마다 당신은 누구인가를 증명하는 번거로운 절차가 없다.
- 하지만 이런 기술적으로 본다면 달라진다. 
  - HTTP 입장에서는 무상태 프로토콜이라 사용자 정보를 따로 저장하고 있지 않다.
  - 그래서 매 요청마다 인증절차가 필요한데 이는 인가에서 다뤄보도록 하자.


### 인가 (Authorization)
- 애플리케이션 내에서 수행할 수 있는 역할이나 권한 혹은 특정 작업을 기반으로 인증이 된 사용자에게 접근 권한을 부여하거나 거부하는 프로세스이다. 
  - 사용자가 할당된 역할이나 책임에 따라 적절한 권한 및 접근 허용할 수 있게 보장한다.
- 인가는 허가의 문제다. 
  - 둘은 구분되지만 일반적으로 인증과 함께 사용된다.
  - 쇼핑몰을 예를 들어 괸리자는 사용자가 할 수 없는 가격 조정이라던지의 권한이 있어야한다. 
  - 관리자페이지가 존재하면 이를 위해 관리자라는 신분을 증명해야하고 (인증) 관리자가 아닌 사용자는 관리자 페이지에 접근할 수 없게해야한다. (인가)


#### 인증과 인가에 대한 사용자 클라이언트 서버 입장을 보자
- 사용자는 accountId와 password를 통해 로그인을 한다. 이 후 접근불가 나오면 인가 과정이 있다는 것을 인지한다.
- 클라이언트의 입장에선 로그인 과정으로 얻은 토큰이나 세션의 세션아이디 등으로 쿠키나 로컬스토리지에 저장하여 서버에 요청마다 인가를 받는다. 
- 서버는 요청에 대한 인증 작업을 진행한다. 
  - 토큰이 유효하다던가
  - 토큰으로 사용자를 확인한다던가
  - 토큰이 만료되진않았는가

#### 특징
- 서버는 모든 요청에 대해 인증과 인가 작업을 수행해야한다.
- S W MVC는 컨트롤러로 요청이 전달되기 전에 핸들러인터셉터로 우리가 원하는 코드를 먼저 실행할 수 있다.
- 스프링 시큐리티를 사용하면 SecurityFilterChain을 통해 우리가 원하는 코드를 먼저 사용할 수 있다.
1. RBAC(역할 기반 액세스 제어)
  - 사용자에게 특정 역할이 할당되고 권한이 해당 역할과 연결된다. 
  - 사용자는 자신의 역할에 할당된 권한을 상속한다.
2. 속성 기반 액세스 제어(ABAC)
  - 액세스 결정은 사용자 속성(예: 부서, 위치, 허가 수준) 및 정의된 정책을 기반으로 한다.
3. 세분화된 액세스 제어
  - 사용자가 애플리케이션 내에서 수행할 수 있는 특정 작업 또는 작업에 따라 액세스가 허용되거나 거부된다.


### HTTP Stateless 
- 웹 브라우저와 웹 서버 간 통신에 사용되는 프토토콜이다.
- 상티 비저장이라고 번역되며 클라어인트에서 서버로의 각 요청이 독립적이다.
    - 이는 이전 요청이나 서버에 저장된 세션 상태에 의존하지 않는 HTTP 프로토콜의 특성을 나타낸다.
- 한마디로 서버가 클라이언트의 정보를 갖고있지 않다는 얘기
- 서버는 요청에 따른 응답만을 한다.
    - 서버는 세션 상태나 컨텍스트를 유지하지 않음

##### 특성 설명 핵심
1. No client Context
  - 서버는 요청 사이의 클라이언트 상태 또는 컨텍스트를 추적하지 않는다. 
  - 각 요청을 새롭고 독립적인 상호 작용으로 처리하는 것을 의미한다.
2. 요청-응답 모델 
  - 그래서 클라이언트의 각 HTTP 요청에는 서버가 응답을 처리하고 생성하는 데 필요한 모든 정보가 포함된다. (일반적으로 헤더에 포함)
  - 그리고 서버는 현재 요청을 이해하기 위해 이전 요청에 의존하지 않는다.
3. 서버측 세션 상테가 없음
  - 서버는 요청 사이에 특정 클라이언트와 관련된 세션별 데이터 혹은 상태를 저장하지 않는다.
  - 세션 관리가 필요한 경우 일반적으로는 각 요청과 힘께 클라이언트가 보낸 세션 토큰 혹은 쿠키를 사용하여 구현된다.
4. 확장성 및 로드 밸런싱
  - HTTP의 상태 비저장 특성으로 인해서 많은 서버를 구축하고 웹 애플리케이션을 수평으로 확장할 수 있다.
  - 공유할 서버 측 상태가 없으므로 동기화 요구 사항 없이 여러 서버에 분산요청도 가능하다.

### 쿠키와 로컬스토리지 
- 둘 다 데이터를 저장하기 위해 웹 브라우저에서 사용할 수 있는 매커니즘이다.
- 하지만 둘 은 목적과 범위 및 용도에 따라 구분된다.

#### 비교
1. 목적
    - 쿠키 
        - 세션관리, 사용자 인증 및 여러 요청에 대한 사용자 행동 추적에 사용됨
        - HTTP와 같은 비상태 프로토콜에서 상태 저장 동작을 유지하는 데 자주 사용됨
    - 로컬 스토리지 
        - 클라어인트 측 데이터 저장을 위해 설계된것.
        - 사용자의 브라우저에 로컬로 데이터를 저장하고 나중에 검색할 수 있는 방법을 제공한다.
2. 저장 용량:
    - 쿠키
        - 쿠키의 저장 용량은 최대 4KB로 제한된다. 
        - 이 제한은 브라우저에 의해 부과되며 브라우저마다 약간씩 다르다.
    - 로컬 스토리지
        - localStorage는 쿠키에 비해 훨씬 더 큰 저장 용량을 제공한다. 
        - 대부분의 최신 브라우저는 최대 5MB 이상의 저장을 허용한다.

3.  데이터 만료
    - 쿠키
        - 쿠키는 만료 날짜를 설정할 수 있다. 
        - 만료 날짜가 있는 쿠키가 생성되면 브라우저 세션 간에도 해당 날짜까지 지속된다. 
        - 만료 날짜를 설정하지 않으면 쿠키는 세션 쿠키가 되며 브라우저 세션이 종료되면 제거된다.
- 로컬 스토리지
    - 로컬 스토리지에 저장된 데이터에는 만료 메커니즘이 내장되어 있지 않다. 
    - 사용자가 명시적으로 지우거나 응용 프로그램에서 제거할 때까지 브라우저에 남아 있다.

4. 범위
    - 쿠키
        - 각 HTTP 요청 및 응답과 함께 클라이언트(브라우저)와 서버 간에 쿠키를 주고 받는다. 
        - 도메인에 따라 다르며 해당 도메인 내의 여러 페이지에서 공유할 수 있다.
    - 로컬 스토리지
        - 원본(프로토콜, 도메인 및 포트의 조합)에 따라 다르다. 
        - 저장된 데이터는 동일한 출처 내의 모든 페이지에서 액세스할 수 있다.

5. 접근성
    - 쿠키
        - 클라이언트측 JavaScript 코드와 서버측 애플리케이션 모두에서 액세스하고 조작할 수 있다. 
        - 서버에 대한 HTTP 요청에 자동으로 포함된다.
    - 로컬 스토리지
        - 클라이언트 측 JavaScript 코드로만 액세스하고 조작할 수 있다. 
        - 데이터는 각 요청과 함께 서버에 자동으로 전송되지 않는다. 
        - 서버 상호 작용 없이 클라이언트 측에서 데이터를 저장하고 검색하는 데 유용하다.

6. 보안
    - 쿠키
        - 제대로 보호되지 않으면 XSS(교차 사이트 스크립팅) 공격 또는 CSRF(교차 사이트 요청 위조) 공격과 같은 보안 위험에 취약할 수 있다.
    - 로컬 스토리지
        - 각 요청과 함께 자동으로 서버에 전송되지 않기 때문에 일반적으로 쿠키보다 더 안전한 것으로 간주된다. 
        - 그러나 적절한 예방 조치를 취하지 않으면 여전히 XSS 공격에 취약하다.


> 둘 다 목적과 사용 시나리오가 다르며 둘 사이의 선택은 응용 프로그램의 특정 요구 사항에 따라 다르니 적절히 선택해서 사용하자.


### 인터셉터 및 필터
- Spring에서 인터셉터와 필터는 모두 HTTP 요청 및 응답을 가로채고 처리하는 데 사용되는 매커니즘
- Spring 프레임워크 내에서 서로 다른 레벨에서 작동하며 서로 다른 기능을 가지고 있다.

#### 인터셉터
- Spring MVC 프레임워크의 일부이며 특정 컨트롤러 또는 핸들러 메서드의 처리 체인 내에서 요청 및 응답을 가로채고 수정하는 방법을 제공.
- 일반적으로 컨트롤러에 도달하기 전이나 후에 로깅, 인증, 권한 부여 또는 요청/응답 수정과 같은 교차 절단 문제를 구현하는 데 사용됨.
- Spring MVC 컨트롤러 내의 메서드 수준에서 작동하며 특정 URL, 컨트롤러 메서드 또는 모든 요청을 가로채도록 구성할 수 있다.
- Spring 빈으로 구현되며 Spring 구성 또는 주석을 사용하여 쉽게 추가 및 구성할 수 있다.

#### 필터
- Java Servlet API의 표준 기능이며 Spring MVC 프레임워크 외부의 요청/응답 처리 체인의 하위 수준에서 작동한다.
- 서블릿 컨테이너에 도달하기 전에 요청 및 응답을 가로채고 헤더 수정, 콘텐츠 변환, 입력 유효성 검사 또는 로깅과 같은 작업을 수행할 수 있다.
- 웹 응용 프로그램의 배포 설명자(web.xml)에서 구성하거나 Servlet API를 사용하여 프로그래밍 방식으로 등록할 수 있다.
- Spring에만 국한되지 않으며 모든 Java 웹 애플리케이션 프레임워크와 함께 사용할 수 있다.
- 요청이 Spring MVC 프레임워크에 도달하기 전에 실행되어 정적 리소스에 대한 요청을 가로채거나 특정 컨트롤러 또는 핸들러 메서드에 연결되지 않은 작업을 수행할 수 있다.


#### 차이점
- 작동 수준
    - 인터셉터는 Spring MVC 수준에서 작동하고 필터는 서블릿 컨테이너 수준에서 작동한다.
- 구성
    - 인터셉터는 일반적으로 Spring에 특정한 구성 파일이나 주석을 사용하여 Spring MVC 프레임워크 내에서 구성된다. 
    - 필터는 웹 응용 프로그램의 배포 설명자에서 구성되거나 Servlet API를 사용하여 프로그래밍 방식으로 구성된다.
- 범위
    - 인터셉터는 Spring MVC 프레임워크에 특정하며 Spring MVC 컨트롤러가 처리하는 요청에만 적용 가능하다. 
    - 필터는 특정 프레임워크에 연결되지 않으며 전체 웹 애플리케이션의 요청에 적용할 수 있다.
- 유연성
    - 인터셉터는 Spring MVC 프레임워크 내에서 컨트롤러 및 모델 개체에 액세스하고 수정하는 측면에서 더 많은 유연성을 제공한다. 
    - 필터는 요청 및 응답 개체에 대해 더 많은 제어 권한을 갖지만 컨트롤러 및 해당 구성 요소에 대한 액세스는 제한된다.
- 이식성
    - 필터는 Java Servlet API의 일부이며 사용 중인 프레임워크에 관계없이 모든 Java 웹 애플리케이션에서 사용할 수 있다. 
    - 반면에 인터셉터는 Spring MVC 프레임워크에 고유하며 다른 프레임워크에 이식할 수 없다.

### 암호화 (Encryption)
- 평문을 변환해서 암호문을 만드는 작업 (가역)
- 암호문을 다시 평문으로 변환하는 작업을 복호화
- 평문으로 되돌릴 수 없는 암호화도 존재 (단방향, 비가역)


#### 특성 설명 및 사례
1. 패스워드 저장같은 경우는 어떻게 할까 ?
- 복호화가 불가능한 암호화방식을 사용함. (비가역)

2. 단방향 암호화를 위해 암호학적 해시 알고리즘 사용한다.
- 해시는 일정한 길이로 만드는것.

```
간단한 해시 함수 f(x) = x % 10 가 암호학적 해시 알고리증민지 검증
평문이 13일 때 암호문은 3이 됨.
```

#### 해쉬 함수
1. 역상 저항성
  - 해시 값(암호문)에서 원래값인 평문을 바로 찾을 수 없어야 한다. 

2. 제2 역상 저항성
  - 원래 값과 다르지만 동일한 해시 값으로 변환되는 다른 값을 찾을 수 없어야 함.
  - 암호문 3으로 원래 값을 바로 찾을 수 없지만 동일한 암호문으로 만드는 3, 23, 33 등의 값을 찾아낼 수 있다. 

3. 충돌 저항성
  - 1, 11, 21, 31 등의 평문이 1이라는 동일한 암호문으로 변환된다는 걸 쉽게 알아낼 수 있음. 


> 단뱡향 암호화를 위해 bcrypt나 scrypt를 많이 썼는데 최근엔 Argon2나 Balloon을 사용한다.


### Salt
- 소금은 특히 암호 해싱에서 암호화 알고리즘의 보안 및 강도를 향상시키기 위해 암호화에 사용된다. 
- 해시되거나 암호화되기 전에 입력(예: 비밀번호)에 추가되는 임의의 값이다. 
- 솔트 값은 일반적으로 해시된 출력과 함께 저장된다.


#### 중요성
1. 암호 보안
- 솔팅은 해시 형식으로 저장된 암호 또는 민감한 데이터를 보호하는 데 도움이 된다. 
- 솔트가 없으면 동일한 비밀번호를 가진 두 명의 사용자가 동일한 해시 값을 가지므로 공격자가 미리 계산된 레인보우 테이블과 같은 기술을 통해 공통 비밀번호를 쉽게 식별할 수 있다. 
- 각 비밀번호에 고유한 솔트 값을 추가하면 비밀번호가 동일하더라도 결과 해시 값이 달라진다.


2. 무작위화
- Salt는 암호화 전에 각 입력에 임의의 고유한 값을 추가한다. 
- 이 임의성은 입력이 동일하더라도 두 개의 동일한 입력이 동일한 출력을 생성할 가능성이 매우 낮다.
- 공격자가 무차별 대입 또는 사전 공격을 통해 패턴을 발견하거나 공통 값을 식별하지 못하도록 방지한다.


3. 미리 계산된 공격에 대한 방어
- 미리 계산된 공격에는 일반적으로 사용되는 암호에 대해 미리 계산된 해시 값의 대규모 데이터베이스 생성이 포함된다
- 솔트를 추가하면 공격자가 각각의 고유한 솔트에 대해 미리 계산된 새로운 값 집합을 생성해야 하기 때문에 미리 계산된 해시 값이 비효율적이 된다.


4. 복잡성 증가
- Salt는 암호화 프로세스의 복잡성을 증가시켜 공격자가 암호화를 리버스 엔지니어링하거나 크래킹하기 어렵게 만든다.
- 공격자가 무차별 대입 공격을 수행하거나 레인보우 테이블을 사용하는 데 계산 비용과 시간이 많이 소요되도록 하여 추가 보호 계층을 추가함.


5. 사용자별 값
- 솔트는 사용자별일 수 있다. 즉, 각 사용자가 고유한 솔트 값을 가질 수 있다.
- 이는 공격자가 해시된 값과 솔트에 대한 액세스 권한을 얻더라도 한 번에 전체 암호 세트를 크래킹하는 대신 각 사용자에 대해 별도의 크래킹 시도를 수행해야 하기 때문에 보안을 더욱 강화한다.




## 학습 키워드
- 인증과 인가
- HTTP Stateless (1주차 복습)
- Cookie vs localStorage
- Interceptor vs Filter in Spring
- 암호화와 복호화
  - 단방향 암호화
  - Hashing algorithm
  - Salt가 필요한 이유