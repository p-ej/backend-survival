# Entity, Value Object


### 전술적 설계
- 애플리케이션의 도메인 계층 내에서 코드를 구조화하고 구성하는 데 사용되는 특정 패턴 및 관행을 나티낸다.
- DDD에서 도메인 계층은 애플리케이션의 핵심 비즈니스 논리 및 개념을 나타낸다. 
- 이 계층 내에서 명확하고 유지 관리 가능한 구조를 생성하여 개발자가 실제 비즈니스 요구 사항을 반영하는 방식으로 도메인을 모델링할 수 있도록 하는 것을 목표로 한다.

#### 간단한 특징 및 패턴
1. Aggregate
  - 일관성 및 트랜잭션 경계의 단일 단위로 취급되는 도메인 개체의 응집력 있는 클러스터이다. 
  - 관련 엔터티 및 값 개체 그룹을 캡슐화하고 해당 경계 내에서 비즈니스 규칙 및 불변성을 적용한다.
2. Entitie
  - 시간이 지남에 따라 연속성을 유지하면서 변경될 수 있는 고유한 ID를 가진 객체를 뜻한다. 
  - 종종 비즈니스 도메인의 주요 행위자이며 행동과 상태를 캡슐화한다.
3. Value Object
  - ID가 아닌 속성으로 정의되는 객체이다. 
  - 변경할 수 없으며 속성 값을 기반으로 공유 및 비교할 수 있다. 
  - 전체 값으로 취급되고 개별적으로 식별할 수 없는 개념을 모델링하는 데 사용된다.
4. Domain Service
  - 본질적으로 특정 엔터티 또는 값 개체에 속하지 않는 작업 또는 동작을 나타낸다.
  - 여러 엔터티를 포함하거나 외부 종속성이 필요한 복잡한 비즈니스 작업을 캡슐화한다.
5. Domain Event
  - 도메인 내에서 중요한 변경 또는 발생을 캡처한다.
  - 상태 변경을 전달하거나 시스템의 다른 부분에서 작업을 트리거하는 데 사용된다.
  - 느슨한 결합을 촉진하고 응용 프로그램의 다른 부분 간에 분리된 통신을 가능하게 한다.
6. Aggregates Root
  - 집계 내의 다른 엔터티 및 값 개체에 액세스하기 위한 게이트웨이 역할을 하는 집계 내의 기본 엔터티
  - 집계 내에서 일관성과 트랜잭션 경계를 보장한다.
7. Repository
  - 데이터 스토리지 계층에서 집계를 저장하고 검색하기 위한 추상화를 제공한다.
  - 데이터 액세스 논리를 캡슐화하고 기본 구현 세부 정보를 노출하지 않고 집계를 쿼리하고 유지하는 방법을 제공한다.
8. Anti-Corruption Layer
  - 디자인이나 구현이 다른 레거시 또는 외부 시스템을 격리하고 적응시키는 데 사용되는 디자인 패턴이다.
  - 외부 시스템의 복잡성과 제약으로부터 코어 도메인을 보호한다.

> 전술적 디자인 패턴과 개념은 도메인의 언어와 개념을 반영하는 방식으로 코드베이스를 구성하는 데 도움이 된다.


### 엔티티 (Entity) vs 일반적으로 이야기하는 개체 (Entity)
#### OOP, DDD의 엔티티
- OOP와 DDD내지 Entity는 속성이 아닌 연속성과 객체를 어떻게 식별할 수 있는가에 따라 정의된다.
  - `엔트맨이 작아지거나 커진다해도 앤트맨이라는 사실 자체는 변하지 않음`
  - `또 앤트맨과 와스프는 구별됨, 심지어 속성이 같은 다른 세계의 엔트맨이 등장해도 둘은 구별된다.`

> 이런식으로 식별자(Identifier = ID)가 존재하고 이를 통해 동일성(Identity)을 확인한다면 Entity라고 할 수 있다.


#### 일반적으로 이야기하는 Entity
- ERD에 존재하는 Entity(객체)
- 고유한 정체성을 가진 뚜렷하고 독립적인 존재를 가진 것을 의미



### 값 객체 (Value Object, VO)
- 어떠한 객체는 Entity와 다르게 연속성과 식별성이 중요하지 않다.

`예를 들면 만원은 만원일뿐 저기에 있는 만원, 여기에 있는 만원으로 굳이 구분지을 필요가 없다는 뜻`

- 그러니까 우리가 만들 쇼핑몰 비즈니스 도메인을 다루기에 적합한 추상화 혹은 모델링이라고 할 수 있다.
  - 현실의 만원은 각각 다르게 생겼지만 만원이라는 교환 가치만 챙기고 나머지는 제거하여 단순하게만 다루자

> 이것이 Value Object이다.

#### 하지만
- 만약 탈세나 위조지폐 같은 검은 돈을 추적한다면 만원의 식별자를 알아야한다.
  - 일련번호를 확인해야하기 때문이다. 여기에서 만원이라는 가치가 중요한것이 아니게 된다.
  - 여기에서 Identifier로 갖는 Entity라고 할 수 있는 것이다.

`즉 만원이 Entity인지 Value Object인지 우리가 미리 정하고 사용하는것이 아니라는 것이다.`

> 오로지 우리의 비즈니스 도메인에 달려있다고 볼 수 있는데, 내가 쇼핑몰 사장인지 FBI 수사팀인지에 따라 비즈니스 도메인을 정하고 객체가 만들어진다고 보면 될 것 같다.

#### 추가로
- Value Object는 속성을 통해 동등성(Equality)을 판단한다. 
- 즉, Value Object는 항상 자바의 equals 메서드를 구현해야 한다.
- 또 예측 가능성을 높이고 혼란을 막기 위해 가능하면 불변 객체로 만들자
  - 동등하다 했는데 속성을 바꾸면 안되듯.. 
  - 예상과 다른 경우 피하기
  - 모든 속성 final


### 동일성(Identity)과 동등성(Equality)
#### 동일성 Identity
- 독특한 객체 혹은 구별되는 존재
- 자체 ID가 존재
  - 객체가 살아있는 동안 일정하게 유지되며 속성이나 상태의 변경에 영향을 받지 안흔다.
- 동일한 속성 또는 값을 가진 두 개체는 메모리에서 별도의 인스턴스인 경우 여전히 다른 ID를 가질 수 있다.
- 일반적으로 객체와 관련된 메모리 주소 또는 고유 식별자 비교있다.

#### 동등성 Equeality
- 사전 정의된 기준에 따라 객체의 동등성 또는 동일성을 나타낸다
- 고유한 ID에 관계없이 두 개체가 동일한 것으로 간주되는지 여부를 결정한다
- 자바에서는 "==" 연산자는 동일성을 확인하는 반면 ".equals()" 메서드는 정의된 기준에 따라 동일한지 확인할 수 있다.
  - 자바스크립트에서 ==와 ===가 존재한다.

> 이름과 나이가 같은 사람의 객체를 생각하면 이해하기 쉬울 것이다.



#### 요약
- 동일성은 객체의 고유한 존재를 의미하는 반면, 동등성은 미리 정의된 기준에 따라 두 객체가 동일한지 여부를 결정한다. 
- 동일성은 변하지 않지만 동등성은 변할 수 있다.


## 학습 키워드
- 전술적 설계 (Tactical Design)
- 엔티티 (Entity) vs 일반적으로 이야기하는 개체 (Entity)
- 값 객체 (Value Object, VO)
- 동일성(Identity)과 동등성(Equality)