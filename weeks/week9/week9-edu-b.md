# “우아한객체지향” 세미나



###객체지향 세미나 

우아한형제들 
개발실장 조영호


객체지향 

의존성을 이용해 설계 진화시키기

설계 핵심 
- 의존성을 어떻게 잡느냐에 따라 설계가 달라짐 
- 역할 책임, 실질적으로 필요한건 의존성을 어떻게 관리하는가

좋은 의존성과 관리방법에따라 설계가 어떻게 바뀌는지 알아보자 

의존성
예제

단계별 설계 변경
의존성 관리 힌트

의존성
￼
설계가 무엇일까 ?
- 코드를 어떻게 배치할 것인가에 대한 의사결정
- 어떤 클래스에 코드, 어떤 패키지에 코드, 오떤 프로젝트에 어떤 코드를 넣을것인가 
- 핵심 : 변경에 초점을 맞추자 
    - 같이 변경되는 코드는 같이 넣고
    - 같이 변경되지 않는 코드는 따로 넣어야함. 
- 변경에대한 핵심은 의존성임 

의존성 개념과 정의 
- A가 B에 의존할 경우 
- 그림으로 보면 B가 변경될때 A도 같이 변경될 수 있다.
    - 클래스 이름이나 메서드 이름, 구현 이름
    - 뭐가 됐던 B가 바꼈을떄 A도 같이 변경가능성이 있다고 볼 수 있을때 의존성
- 변경과 관련된것
- 이게 있다고 무조건 같이 변경되냐 ? 꼭 그렇지만은 않음 
    - 설계를 잘하면 서로 영향없이 바뀔 수 잇음
- 영향을 받을 수 있는 가능성임 
- 클래스 상, 패키지 상 디펜던시


클래스 의존성의 종류
￼
- 연관관계의 정의
    - A에서 B로 이동할 수 있다.
    - 객체 참조
    - 영구적 경로

￼
- 의존 관계
    - 파라미터에 타입이 나오거나
    - 리턴타입에 그 타입이 나오거나
    - 메소드 안에서 그 타입의 인스턴스를 생성한다.
    - 일시적, 관계만 맺고 헤어지는 관계
￼
- 상속 관계
    - B라는 클래스의 구현을 A가 상속받는다. 
    - B가 바뀔때 A클래스도 같이 변경
    - 구현이 바뀌면 영향을 받을 수 있다.
￼
- 실체화 관계 
    - 인터페이스
    - 인터페이스의 오퍼레이션 시그니처가 바뀌었을때만 영향을 받음

- 패키지 A가 패키지 B에 의존을 한다.
    - 패키지 B의 클래스가 바뀔때 A의 클래스도 바뀔 확률이 있음
    - import 가 있으면 의존성이 있다.라고 보면됨

좋은 의존성을 위한 규칙 (정답은아니지만)
양방향 의존성을 피하자
￼
예를 들어 A -> B로 가는 의존성과 B -> A로 가는 의존성이 있다하자
- B가 바뀔때 A변경 A가 바뀔때 B가 변경
- A클래스의 세터 메서드에서 B클래스의 세터 메서드를 콜함.
- A와 B 사이의 관계를 동기화 해야함
- 성능 이슈
- 싱크를 맞추는거에 많은 버그가 일어남
- 피할 수 있으면 단방향으로 바꾸자
￼
A : [(1, B1), (2, B2), (3, B3)]

B : 1, A
B : 2, A
B : 3, A

- 성능이슈
- 객체 관계유지 힘듦
- A가 B의 리스트를 갖는것보다 B가 A의 단방향 참조를 갖는게 가장 좋음
- 다중성이 좋은 의존성방향이 좋다
￼
- 제거가 가장좋음
- 패키지가 같이 바뀜

설계원칙
- 중요한건 변경
- 어떻게 바뀔거야 초점
- 하나의 패키지관계를 피하자


기본적인 의존성 관리 법칙
- 양방향은 피하기
- 다중성이 적은 방향
- 필요없는 의존성 제거
- 의존성 사이클이 생기지 않게

예제

주문 플로우
- 가게 상세 (가게 선택) -> 메뉴 선택 -> 1개담기 (장바구니 화면) -> 주문 , 주문완료


런타임 구성


1인 세트 등록
메뉴를 쭉 노출
사용자가 선택
1인 세트 장바구니 담기 

￼

사용자가 장바구니에 담을때마다 서버로 저장을 요청하는게 아니라 핸드폰 로컬에 저장함.
핸드폰 바뀌면 장바구니 날아감



여기서 사용자가 장바구니에 메뉴를 담기 주문하기 전에 사장이 메뉴나 가격을 바꾸었을때 
핸드폰 로컬 장바구니에 담긴 메뉴랑 등록한 메뉴의 불일치가 발생함 




주문전송 데이터와 사장님이 등록한 데이터가 일치하는지 검증해야함.

어떤 항목을 검증할까 ?
- 실무는 엄청나게 많은 데이터를 검증함. 




메뉴의 이름과 주문항목의 이름 비교
옵션그룹의 이름과 주문옵션그룹의 이름 비교
- 가격은 같지만 짜장과 짬뽕은 다름
옵션의 이름과 주문옵션의 이름 비교
옵션의 가격과 주문옵션의 가격 비교
가게가 영업중인지 확인
주문금액이 최소주문금액 이상인지 



협력을 설계할떄 객체에대한 얘기를 하지만 개념을 보자
￼

- 주문 데이터가 만들어지고 주문하기플로우 즉, 주문하기 메세지가 전송됨 
    - 검증 로직을 시작함
    - 주문이 들어왔는지 사장에게 알려도되는지 ? 
- 가게가 영업중인지 확인 ? 
- 주문금액이 최소주문금액 이상인지?
- 메뉴의 이름과 주문항목의 이름 비교
- 옵션그룹의 이름과 주문옵션그룹의 이름비교
- 옵션의 이름과 주문옵션의 이름 비교
- 옵션의 가격과 주문옵션의 가격 비교
- 이것들이 다 통과를 하면 주문이 완료됐다고 가정

플로우는 주문이 가게쪽에 메세지 주문이 주문항목 , 메뉴 -> 옵션그룹 -> 옵션 이런식임 
￼

트레이드 오프를 선택한 기준


￼

의존성 관점에서 설계를 살펴보자
동적인 객체와 객체사이 메세지를 결정(의사결정)

￼
코드상에 정적인 부분을 심어줘야함
클래스끼리의 협력

코드에다가 인스턴스 변수를 넣거나 어떤 메서드에 파라미터를 넣거나 할떄마다 어떤 의사결정을 하냐는거면 이 타입의 객체와 이 타입의 객체는 런타임에 협력할거야 라는 의사결정을 하는것.

어떤 방식으로든 이 협력이란것을 정적인 코드로 표현해야함.

의존성에 포커스를 맞추기 

관계는 방향성이 필요함. 
의존성은 어떤애가 어떤애한테 의존해라는것이 잇음
소스부터 타겟이 필요
의존성이 어떤 방향으로 흐를거임
디비는 FK잡으면 방향성이 없어도됨 
객체는 실제 방향성이 잡히면 어떤 방식으로든 구현을 해야함.

￼
객체의 협력 방향에 따라서 관계의 결정이 달라짐 
런타임에 객체들이 어떤 방향으로 협력하고 있어라는걸 바탕으로해서 관계를 잡아야함. 

데이터적으로 이 관계는 필요해 라는것은 있음

기본은 객체와 객체사이 
메세지를 통해서 관계의 방향을 잡자
- 이것이 의존성의 방향이 됨.

런타임 협력 관계를 가지고 의존성의 방향을 잡자

1. 연관
2. 의존관계
3. 상속관계 명확 extends
4. 실체화관계 명확 implements

연관, 의존관계가 남음


￼
- 객체 참조


￼
- 내부 new 
- 


관계설정보다 방향성이 중요함 
의존관계를 넣는 이유가 있어야함.
어떻게 협력하느냐에 따라 달라짐

￼
- 오더를 알면 오더를 통해 내가 원하는 오더라인아이템에 액세스할 수 있다가 연관관계의 정의 
- 객체를 알면 내가 원하는 다른 객체를 찾아갈 수 있어 가 연관관계의 정의

￼

일반적으로 연관관계를 구현하는 방법은 객체참조를 사용하는것이다.

￼

여러 방법이 있긴함
연관관계라고 하는 개념
- 개념은 구현방법이 되게 많음

객체참조는 대표적인 방법중하나 

구현시작
public class Order {
	public void place() {
	  validate();
	  ordered();
	}
	private void validate() {	}
	private void ordered() {
	}
}
￼

주문하기의 협력은 order라는 객체
주문하기 라는 메소드 메세지가 도착했을떄 시작 

순서는 
메시지를 결정하고 메소드를 만드는듯

메소드 형태 
- 주문이 올바른지
- 주문의 상태를 바꾸는

객체 협력

￼

전체 검증로직
￼

- 비즈니스 로직을 구현하는 객체들 사이 관계
- 도메인 영역에서 벗어나는 구역들도 구현해야함.


클래스 구현
코드 구현과정은 지저분할 수 있음
일단 코드 짜자
디펜던시를 보면서 개선을하자 

설계를 진화시키기 위한 출발점
코드 작성 후 의존성 관점에서 설계 검토 

클래스들이 구체적인것에 의존하지말고 추상화에 의존하자 
선입견 주의 : 
- 추상클래스나 인터페이스이어야 해라는 선입견이 있다.

실제적 추상화라는것은
- 잘 안변하는 것.
- 어떤거의 의해서 잘 변하지 않아

￼

객체참조의 문제
- 메모리상에선 큰 이슈가 안되지만 
- orm, DB 매핑을 하면 lazy 이슈가 엄청 발생함. 

￼
트랜잭션이 물리는 주기도 달라짐 

사용자한테 보여지는 로직이 에러가 떨어짐 

트랜잭션 락이 걸렸음 
어드민에 의해서 

객체들을 쫓아가면서 트랜잭션을 걸다보면 ….. .


객체참조가 정말 필요한가 ? 


￼

객체 참조는 결합도가 가장 높은 의존성이다.

필요한 경우 객체참조를 끊어야한다.
￼

트랜잭션안에는 뭐가들어가야함 ?
- 같이 변경되어야하는것.
- 어떤건 같이 변경되어야하는것
- 같이 생성되고 같이 제거가 되는것은 묶어야함
- 하나의 단위로 움직여야하는것은 트랜잭션으로 묶어야함. 
    - 같이 묶는건 결합도가 높ㅍ은것 (객체 참조 사용가능)
- 비즈니스 룰에따라 결정이 됨.
￼

같이읽어야하는 lazy loading

같이 생성 같이 삭제 같이 수정 cascade 룰
연관관계로 묶는것이 나음

id참조하기 


- 개념을 설명하기 위해 객체참조를 많이 사용함

실제 실무레벨은 객체의 맺고끊음이 중요함.


객체 참조에서 id로 바뀌면 컴파일에러남
이 문제를 해결해야함


객체를 직접 참조하는 로직을 다른 객체로 옮기자.
￼
좋은 설계인 이유


절차지향적
￼
- 비즈니스 플로우가 한눈에 보임
￼


잘된 설계인지 의존성 확인


인터페이스를 이용해서 의존성을 역전시키자
￼

좀더 추상적인 중간객체를 만들어 변환
￼

인터페이스나 추상클래스로 의존성 역전


두번째 방법
도메인 이벤트 퍼블리싱

오더가 바뀔때 딜리버리 샵이 바뀌어야함.
기존 문제 : 결합도가 높았음
목적 : 느슨하게 끊고싶음
- 잘게 찢어서 느슨하게


객체 참조를 해서 결합되어 있는 것을 로직안에 한군데에 모아서 객체간에 결합도는  낮지만 로직간의 결합도는 명확하게 보여주고 싶어가 서비스에 대한 개념
도메인 이벤트는 아니야 나는 다른 이유로인해서 A가 끝낫을떄 B, C가 시작됏음 좋겠어 하지만 최대한 얘네들의 순서를 느슨하게 만들고 싶어


￼
오더의 상태가 바뀌면 OrderDelivered Event 라는것이 발행 

이벤트를 받아 상태를 바꿈
메시징은 상관없고 메모리상에서 일어나는 일 

￼
- 누군가가 이벤트 메세지를 받을 수 있게 발행
- 핸들러로 요청받기


￼
- Order가 Shop을 호출하는 로직을 위의 사진과 같이 변경
- 디비 커밋을 할때 해당 이벤트를 발행해줌 (스프링 데이터쪽에서)
- 그것을 받아 처리함.

￼
- 동기도가능 
- 다른 트랜잭션에서도 처리 가능
￼

3번쨰 방법 

￼
- 중간객체

￼
- 인터페이스나 추상클래스 사용


판단에 따라 다른 방법



의존성과 시스템 분리
￼
- 기존에는 서비스나 도메인 레이어 단위로 나눔 
- 의존성 사이클이 존재하기 떄문
    - 샵을 앞으로 넣었을떈

관리할떄 
디펜던시 관점
어떤 타이밍에 어디서 끊어야하는지 판단하는게 중요


의존성을 따라 시스템을 진화시켜라 


